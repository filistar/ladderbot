const dotenv = require("dotenv").config();
const TMI = require("tmi.js");
const { initializeDatabase, loadRegisteredUsers, checkUserOrIdRepeated, insertNewChannelLadderId, deleteRegisteredUser, makeLadderRequest } = require("./utils");

const BOT_NAME = process.env.BOT_NAME; // bot twitch name in lower case
const TMI_OAUTH = process.env.TMI_OAUT; // Oauth password
const CHAT_COMMANDS = {
	SCHEDULE: "schedule",
	LADDER_COMMAND: "!ladder",
	JOIN_COMMAND: "!join",
	LEAVE_COMMAND: "!leave",
};
const channelList = [BOT_NAME];
let client;

async function init() {
	initializeDatabase();
	loadRegisteredUsers()
		.then((response) => {
			channelList.push(...response);
			connectBot();
		})
		.catch((error) => console.error(error.stack));
}

/**
 * connectBot
 */
function connectBot() {
	const TMI_OPTIONS = {
		identity: {
			username: BOT_NAME,
			password: TMI_OAUTH,
		},
		channels: channelList, // channel(s) name where the bot should post
	};

	client = new TMI.client(TMI_OPTIONS);
	client.on("connected", onConnectedHandler);
	client.connect();
	client.on("message", onMessageHandler);
}

/**
 * @param {string} address
 * @param {number} port
 */
function onConnectedHandler(address, port) {
	console.log(`Successfully Connected to ${address}:${port}`);
}

/**
 * @param {string} channel Channel name
 * @param {object} tags
 * @param {string} tags.username Username that generated the message
 * @param {string} message Message sent in chat
 * @param {boolean} self Flag to determine if the message was generated by the bot
 * @returns void
 */
function onMessageHandler(channel, tags, message, self) {
	// Ignores messages that come from the bot
	if (self) {
		return;
	}

	let trimmedMessage = message.trim();
	let splitMessage = trimmedMessage.toLowerCase().split(" ");

	if (channel === `#${BOT_NAME}`) {
		switch (splitMessage[0]) {
			case CHAT_COMMANDS.LADDER_COMMAND:
				handleLadderCommand(splitMessage, channel, tags.username);
				break;
			case CHAT_COMMANDS.JOIN_COMMAND:
				handleJoinRequest(splitMessage, channel, tags.username);
				break;
			case CHAT_COMMANDS.LEAVE_COMMAND:
				handleLeaveRequest(channel, tags.username);
				break;
			default:
				client.say(`${tags.username}, that command doesnt exist.`);
		}
		return;
	}

	if (splitMessage[0] === CHAT_COMMANDS.LADDER_COMMAND) {
		handleLadderCommand(splitMessage, channel, tags.username);
	}
}

/**
 * @param {string[]} command
 * @param {string} channel
 * @param {string} username
 */
function handleJoinRequest(command, channel, username) {
	console.log("handleJoinRequest");
	if (command.length === 1 || isNaN(command[1])) {
		client.say(
			channel,
			`A valid LADDER user ID is missing. Please use the join command as follows: !join 9999 .`
		);

		client.say(
			channel,
			`The Ladder ID are the last numbers in the URL of your Ladder profile. ie https://alttprladder.com/Racers/Index/9999 . In this case the Ladder ID would be 9999`
		);

		return;
	}
	const ladderId = command[1];

	if (!isNaN(ladderId)) {
		makeLadderRequest(`GetRacerDetails?racer_id=${ladderId}`)
			.then(async (response) => {
				if (response.success) {
					if (response.body.racer_id !== 0) {
						checkUserOrIdRepeated(username, ladderId)
							.then((response) => {
								if (response.found) {
									if (response.channel) {
										client.say(channel, `You are already registered, please check your channel chat ${username}`);
									} else if (response.ladderId) {
										// please contact Alucard or Filistea on Discord...?
										client.say(channel, `The ladder user id is already registered`);
									}
								} else {
									insertNewChannelLadderId(username, ladderId)
										.then((insertResponse) => {
											if (insertResponse && insertResponse.code) {
												client.say(channel, `You are already registered, please check your channel chat ${username}`);
											} else {
												// If user id doesnt exist in the DB
												client.join(`#${username}`).then(() => {
													client.say(
														`#${BOT_NAME}`,
														`${username} welcome! You can find the commands available for your channel in the about section: https://www.twitch.tv/fluteduck/about`
													);
													client.say(
														`#${BOT_NAME}`,
														`NOTE: You need set the bot as MODERATOR in order for it to work properly! Whenever you unsuscribe from the bot you can un-mod it.`
													);
												});
											}
										})
										.catch((error) => {
											throw error;
										});
								}
							})
							.catch(() => displayErrorMessage(channel));
					} else {
						client.say(channel, `That racer id does not exist.`);
					}
				} else {
					console.warn("error", response);
					displayErrorMessage(channel);
				}
			})
			.catch((error) => {
				console.warn(error);
				displayErrorMessage(channel);
			});
	}
}

/**
 * @param {string[]} command
 * @param {string} channel
 * @param {string} username
 */
function handleLadderCommand(command, channel, username) {
	console.log("handleLadderCommand");
	if (command.length > 0) {
		getTodaysLadderSchedule(channel);
	}
}
/**
 * @param {string} channel
 * @param {string} username
 */
async function handleLeaveRequest(channel, username) {
	if(channel !== `#${BOT_NAME}`) {
		deleteRegisteredUser(username)
		.then(() => {
			client.part(`#${username}`);
			client.say(`#${BOT_NAME}`, `${username} is no longer subscribed. You'll be missed.`);
		})
		.catch(() => displayErrorMessage(channel));
	}
	
}

/**
 * Gets the ladder races for the day
 * @param {string} channel
 */
async function getTodaysLadderSchedule(channel) {
	console.log("getTodaysLadderSchedule");
	try {
		let races = await getLadderShcedule();
		if (races.length > 0) {
			let nextRaces = races.slice(0, 6);
			client.say(channel, "NOTE: All times are US Eastern");
			nextRaces.forEach((element) => {
				client.say(channel, `${element.StartTime} - [${element.Mode}]`);
			});
		} else {
			displayErrorMessage(channel);
		}
	} catch (error) {
		let races = [];
		console.warn(error); // from creation or business logic
	}
}

/**
 * Gets the ladder schedule for the current season, filtering out past races
 */
async function getLadderShcedule() {
	console.log("getLadderShcedule");
	let season = await getLatestLadderSeason();
	let path = `/GetSchedule?season_id=${season.season_id}`;

	return new Promise((resolve, reject) => {
		if (season && season.season_id) {
			makeLadderRequest(path)
				.then((response) => {
					if (response.success) {
						schedule = response.body.filter((race) => !race.HasCompleted);
						resolve(schedule);
					} else {
						resolve([]);
					}
				})
				.catch((error) => {
					console.warn("error", error);
					reject([]);
				});
		} else {
			reject([]);
		}
	});
}

/**
 * Gets the information for the current ladder season
 */
function getLatestLadderSeason() {
	console.log("getLatestLadderSeason");
	return new Promise((resolve, reject) => {
		makeLadderRequest("GetSeasons")
			.then((response) => {
				if (response.success) {
					ladderSeason = response.body.find((season) => season.IsCurrentSeason === true);
					resolve(ladderSeason);
				} else {
					console.warn("Couldnt get latest ladder season");
					resolve({});
				}
			})
			.catch((error) => {
				console.warn("error", error);
				reject({});
			});
	});
}

/**
 * @param {string} channel
 */
function displayErrorMessage(channel) {
	client.say(channel, "Oops! Something went wrong");
}

init();
