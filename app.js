const TMI = require('tmi.js');
var needle = require('needle');
require('dotenv').config();

const BOT_NAME = "<bot>"; // bot twitch name in lower case
const TMI_OAUTH = "<oauth>"; // Oauth password
const TMI_OPTIONS = {
    identity: {
        username : BOT_NAME,
        password : TMI_OAUTH
    },
    channels: [
        '<channel>' // channel(s) name where the bot should post
    ]
}

const LADDER_COMMAND = '!ladder'
const LADDER_URL = 'https://alttprladder.com/api/v1/PublicAPI/'

const client = new TMI.client(TMI_OPTIONS);
client.on('connected', onConnectedHandler);
client.connect();
client.on('message', onMessageHandler);

/**
 * @param {string} address 
 * @param {number} port 
 */
function onConnectedHandler(address, port){
    console.log(`Successfully Connected to ${address}:${port}`);
};

/**
 * @param {string} channel Channel name
 * @param {object} tags 
 * @param {string} tags.username Username that generated the message
 * @param {string} message Message sent in chat
 * @param {boolean} self Flag to determine if the message was generated by the bot
 * @returns void
 */
function onMessageHandler(channel, tags, message, self) {
    // Ignores messages that come from the bot
    if (self) {
        return
    }

    let trimmedMessage = message.trim();
    let splitMessage = trimmedMessage.toLowerCase().split(" ");

    if(splitMessage[0] === LADDER_COMMAND) {
        handleLadderCommand(splitMessage, channel, tags.username)
    }
}

/**
 * @param {string[]} command 
 */
function handleLadderCommand(command, channel, username){
    switch (command[1]) {
        case 'schedule': {
            getTodaysLadderSchedule(channel);
            break;
        }
        default:
            client.say(channel, 'Oops! Something went wrong MrDestructoid')
    }
}

/**
 * Gets the ladder races for the day
 */
async function getTodaysLadderSchedule(channel) {
    let races = await getLadderShcedule();
    if(races.length > 0){
        let nextRaces = races.slice(0,6);
        client.say(channel, 'NOTE: All times are US Eastern MrDestructoid')
        nextRaces.forEach(element => {
            client.say(channel, `${element.StartTime} - [${element.Mode}]`)
        });
    } else {
        client.say(channel, 'Oops! Something went wrong MrDestructoid')
    }
}

/**
 * Gets the ladder schedule for the current season, filtering out past races
 */
async function getLadderShcedule(){
    let season = await getLatestLadderSeason();
    let path = `/GetSchedule?season_id=${season.season_id}`;
    return new Promise((resolve, reject)=>{
        makeLadderRequest(path).then(response => {
            if (response.success) {
                schedule = response.body.filter(race => !race.HasCompleted);
                resolve(schedule);
            }
        }).catch(error => {
            console.warn('error',error);
            reject([]);
        });
    })
}

/**
 * Gets the information for the current ladder season
 */
function getLatestLadderSeason(){
    return new Promise ((resolve, reject) => {
        makeLadderRequest('GetSeasons').then(response => {
            if(response.success) {
                ladderSeason = response.body.find(season => season.IsCurrentSeason === true);
                resolve(ladderSeason);
            } else {
                console.warn('Couldnt get latest ladder season')
                reject({});
            }
        }).catch(error => {
            console.warn('error',error);
            reject({});
        });
    });
}

/**
 * Handles the requests to the Ladder API
 * @param {string} path 
 */
function makeLadderRequest(path){
    console.log('makeLadderRequest -', `${LADDER_URL}${path}`)

    const request = new Promise ((resolve, reject) => {
        needle('get', `${LADDER_URL}${path}`).then(response => {
            if(response.statusCode === 200){
                resolve({
                    success: true,
                    body: response.body,
                    errorMessage: null
                });
            } else {
                reject({
                    success: false,
                    body: null,
                    errorMessage: `Something went wrong. Status code: ${response.statusCode}`
                });
            }
            
        }).catch(error => {
            reject({
                success: false,
                body: null,
                errorMessage: error
            });
        });
    });
    return request;
}