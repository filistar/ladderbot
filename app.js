const dotenv = require("dotenv").config();
const TMI = require("tmi.js");
const needle = require("needle");
const { Pool } = require("pg");

const BOT_NAME = process.env.BOT_NAME; // bot twitch name in lower case
const TMI_OAUTH = process.env.TMI_OAUT; // Oauth password
const LADDER_URL = "https://alttprladder.com/api/v1/PublicAPI/";
const CHAT_COMMANDS = {
	SCHEDULE: "schedule",
	LADDER_COMMAND: "!ladder",
	JOIN_COMMAND: "!join",
	LEAVE_COMMAND: "!leave",
};
const sqlPool = new Pool({
	connectionString: process.env.DATABASE_URL,
	user: process.env.DATABASE_USER,
	ssl: {
		rejectUnauthorized: false,
	},
});
const channelList = [BOT_NAME];
let client;

async function init() {
	const sqlClient = await sqlPool.connect();
	try {
		await sqlClient.query("SELECT id,channel FROM registered_channels;", (err, res) => {
			if (err) throw err;
			for (let row of res.rows) {
				channelList.push(row.channel);
			}
		});
	} catch (error) {
		console.log(error.stack);
	} finally {
		// Make sure to release the sqlClient before any error handling,
		// just in case the error handling itself throws an error.
		sqlClient.release();
		connectBot();
	}
}

/**
 * connectBot
 */
function connectBot() {
	const TMI_OPTIONS = {
		identity: {
			username: BOT_NAME,
			password: TMI_OAUTH,
		},
		channels: channelList, // channel(s) name where the bot should post
	};

	client = new TMI.client(TMI_OPTIONS);
	client.on("connected", onConnectedHandler);
	client.connect();
	client.on("message", onMessageHandler);
}

/**
 * @param {string} address
 * @param {number} port
 */
function onConnectedHandler(address, port) {
	console.log(`Successfully Connected to ${address}:${port}`);
}

/**
 * @param {string} channel Channel name
 * @param {object} tags
 * @param {string} tags.username Username that generated the message
 * @param {string} message Message sent in chat
 * @param {boolean} self Flag to determine if the message was generated by the bot
 * @returns void
 */
function onMessageHandler(channel, tags, message, self) {
	// Ignores messages that come from the bot
	if (self) {
		return;
	}

	let trimmedMessage = message.trim();
	let splitMessage = trimmedMessage.toLowerCase().split(" ");

	if (channel === `#${BOT_NAME}`) {
		switch (splitMessage[0]) {
			case CHAT_COMMANDS.LADDER_COMMAND:
				handleLadderCommand(splitMessage, channel, tags.username);
				break;
			case CHAT_COMMANDS.JOIN_COMMAND:
				handleJoinRequest(splitMessage, channel, tags.username);
				break;
			case CHAT_COMMANDS.LEAVE_COMMAND:
				handleLeaveRequest(channel, tags.username);
				break;
			default:
				client.say(`${tags.username}, that command doesnt exist.`);
		}
		return;
	}

	if (splitMessage[0] === CHAT_COMMANDS.LADDER_COMMAND) {
		handleLadderCommand(splitMessage, channel, tags.username);
	}
}

/**
 * @param {string[]} command
 * @param {string} channel
 * @param {string} username
 */
function handleJoinRequest(command, channel, username) {
	console.log("handleJoinRequest");
	if (command.length === 1 || isNaN(command[1])) {
		client.say(
			channel,
			`A valid ladder user id is missing. Please use the join command as follows: !join 9999 . 
        If you dont know your user ID you can find the instructions in this channel's about section`
		);

		return;
	}
	const ladderId = command[1];

	if (!isNaN(ladderId)) {
		makeLadderRequest(`GetRacerDetails?racer_id=${ladderId}`)
			.then(async (response) => {
				if (response.success) {
					if (response.body.racer_id !== 0) {
						const sqlClient = await sqlPool.connect();
						try {
							sqlClient.query(`SELECT channel, ladder_id from registered_channels WHERE channel=$1`, [username], (error, res) => {
								if (!error) {
									if (res.rows[0]) {
										client.say(channel, `You are already registered, please check your channel chat ${username}`);
									} else {
										sqlClient.query(`SELECT channel, ladder_id from registered_channels WHERE ladder_id=$1`, [ladderId], (error, res) => {
											if (!error) {
												if (res.rows[0]) {
													// please contact Alucard or Filistea on Discord...?
													client.say(channel, `The ladder user id is already registered`);
												} else {
													sqlClient.query(`INSERT INTO registered_channels(channel, ladder_id) VALUES ($1, $2);`, [username, ladderId], (err, res) => {
														if (err) {
															console.error(err);
															// unique_violation
															if (err.code === "23505") {
																client.say(channel, `You are already registered, please check your channel chat ${username}`);
															} else {
																displayErrorMessage(channel);
															}
														} else {
															// If user id doesnt exist in the DB
															client.join(`#${username}`).then(() => {
																client.say(
																	`#${BOT_NAME}`,
																	`${username} welcome! You can find the commands available for your channel in the about section: https://www.twitch.tv/fluteduck/about`
																);
																client.say(
																	`#${BOT_NAME}`,
																	`NOTE: You need set the bot as MODERATOR in order for it to work properly! Whenever you unsuscribe from the bot you can un-mod it.`
																);
															});
														}
													});
												}
											} else {
												displayErrorMessage(channel);
											}
										});
									}
								} else {
									displayErrorMessage(channel);
								}
							});
						} finally {
							sqlClient.release();
						}
					} else {
						client.say(channel, `That racer id does not exist.`);
					}
				} else {
					console.warn("error", response);
					displayErrorMessage(channel);
				}
			})
			.catch((error) => {
				console.warn(error);
				displayErrorMessage(channel);
			});
	}
}

/**
 * @param {string[]} command
 * @param {string} channel
 * @param {string} username
 */
function handleLadderCommand(command, channel, username) {
	console.log("handleLadderCommand");
	if (command.length > 0) {
		getTodaysLadderSchedule(channel);
	}
}
/**
 * @param {string} channel
 * @param {string} username
 */
async function handleLeaveRequest(channel, username) {
	const sqlClient = await sqlPool.connect();
	try {
		sqlClient.query(`DELETE FROM registered_channels WHERE channel=$1`, [username], (error, res) => {
			if (!error) {
				client.part(`#${username}`);
				client.say(`#${BOT_NAME}`, `${username} is no longer subscribed. You'll be missed.`);
			} else {
				displayErrorMessage(channel);
			}
		});
	} finally {
		sqlClient.release();
	}
}

/**
 * Gets the ladder races for the day
 * @param {string} channel
 */
async function getTodaysLadderSchedule(channel) {
	console.log("getTodaysLadderSchedule");
	try {
		let races = await getLadderShcedule();
		if (races.length > 0) {
			let nextRaces = races.slice(0, 6);
			client.say(channel, "NOTE: All times are US Eastern");
			nextRaces.forEach((element) => {
				client.say(channel, `${element.StartTime} - [${element.Mode}]`);
			});
		} else {
			displayErrorMessage(channel);
		}
	} catch (error) {
		let races = [];
		console.warn(error); // from creation or business logic
	}
}

/**
 * Gets the ladder schedule for the current season, filtering out past races
 */
async function getLadderShcedule() {
	console.log("getLadderShcedule");
	let season = await getLatestLadderSeason();
	let path = `/GetSchedule?season_id=${season.season_id}`;

	return new Promise((resolve, reject) => {
		if (season && season.season_id) {
			makeLadderRequest(path)
				.then((response) => {
					if (response.success) {
						schedule = response.body.filter((race) => !race.HasCompleted);
						resolve(schedule);
					} else {
						resolve([]);
					}
				})
				.catch((error) => {
					console.warn("error", error);
					reject([]);
				});
		} else {
			reject([]);
		}
	});
}

/**
 * Gets the information for the current ladder season
 */
function getLatestLadderSeason() {
	console.log("getLatestLadderSeason");
	return new Promise((resolve, reject) => {
		makeLadderRequest("GetSeasons")
			.then((response) => {
				if (response.success) {
					ladderSeason = response.body.find((season) => season.IsCurrentSeason === true);
					resolve(ladderSeason);
				} else {
					console.warn("Couldnt get latest ladder season");
					resolve({});
				}
			})
			.catch((error) => {
				console.warn("error", error);
				reject({});
			});
	});
}

/**
 * @param {string} channel
 */
function displayErrorMessage(channel) {
	client.say(channel, "Oops! Something went wrong");
}

/**
 * Handles the requests to the Ladder API
 * @param {string} path
 */
function makeLadderRequest(path) {
	console.log("makeLadderRequest -", `${LADDER_URL}${path}`);

	const request = new Promise((resolve, reject) => {
		needle("get", `${LADDER_URL}${path}`)
			.then((response) => {
				if (response.statusCode === 200) {
					resolve({
						success: true,
						body: response.body,
						errorMessage: null,
					});
				} else {
					resolve({
						success: false,
						body: null,
						errorMessage: `Something went wrong. Status code: ${response.statusCode} . Path: ${path}`,
					});
				}
			})
			.catch((error) => {
				reject({
					success: false,
					body: null,
					errorMessage: error,
				});
			});
	});
	return request;
}

init();
