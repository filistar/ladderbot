const TMI = require('tmi.js');
const request = require('request');

const BOT_NAME = "<bot>"; // bot twitch name in lower case
const TMI_OAUTH = "<oauth>"; // Oauth password
const TMI_OPTIONS = {
    identity: {
        username : BOT_NAME,
        password : TMI_OAUTH
    },
    channels: [
        '<channel>' // channel(s) name where the bot should post
    ]
}

const LADDER_COMMAND = '!ladder'
const LADDER_URL = 'https://alttprladder.com/api/v1/PublicAPI/'

const client = new TMI.client(TMI_OPTIONS);
client.on('connected', onConnectedHandler);
client.connect();
client.on('message', onMessageHandler);

/**
 * @param {string} address 
 * @param {number} port 
 */
function onConnectedHandler(address, port){
    console.log(`Successfully Connected to ${address}:${port}`);
};

/**
 * @param {string} target Channel name
 * @param {object} tags 
 * @param {string} tags.username Username that generated the message
 * @param {string} message Message sent in chat
 * @param {boolean} self Flag to determine if the message was generated by the bot
 * @returns void
 */
function onMessageHandler(target, tags, message, self) {
    // Ignores messages that come from the bot
    if (self) {
        return
    }

    let trimmedMessage = message.trim();
    let splitMessage = trimmedMessage.toLowerCase().split(" ");

    if(splitMessage[0] === LADDER_COMMAND) {
        handleLadderCommand(splitMessage)
    }
}

/**
 * @param {string[]} message 
 */
function handleLadderCommand(message){
    const RACER_ID = 667;
    switch (message[1]) {
        case 'schedule': {
            const path = `GetRacerHistory?racer_id=${RACER_ID}`
            // TODO: Make ladder request.
            break;
        }
        default:
            response = {};
    }
}

/**
 * @param {string} path 
 */
function makeLadderRequest(path){
    console.log('makeLadderRequest -', `${LADDER_URL}${path}`)
    // TODO: Add async solution
    request(`${LADDER_URL}${path}`, (error, response, body) => {
        if(response.statusCode){
            return {
                success: true,
                body
            }
        } else {
            return {
                success: false,
                body: null
            }
        }
    });
}